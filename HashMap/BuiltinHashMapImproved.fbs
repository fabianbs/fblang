// Improvings: 
//   - robin-hood hashing with backshift removal
//   - nocopy bucket realloc => value-reference stability

def void HashMap<U, T>{
    def const void Slot{
        final internal zint hashCode
        final internal Bucket! buck
        final internal uint distance
        internal init ctor(zint _hashCode, Bucket! buck, uint distance){
            hashCode = _hashCode | 1
        }
        internal copy ctor(const Slot& s){}
        internal bool isFull() -> hashCode & 1
        internal bool clear(){
            hashCode = 0
        }
    }
    def const void Bucket{
        final internal U key
        final internal T value
        internal init ctor(U key, T value){}
    }
    final float LOAD_FACTOR = 0.8
    
    static bool equals(U ky1, U ky2){
        #if(U is nullable){
            if(ky1 == null)
                return ky2 == null
            else if(ky2 == null)
                return false
        }
        
        #if(U is integer || U is string){
            return ky1 == ky2
        }
        #elif(equals(U)->bool in U){
            return ky1.equals(ky2)
        }
        #elif(static equals(U,U)->bool in U){
            return U.equals(ky1, ky2)
        }
        #elif(operator==(U)->bool in U){
            return ky1 == ky2
        }
        #elif(static operator==(U, U)->bool in U){
            return ky1 == ky2
        }
        #elif(U is &){
            return (nativehandle)ky1 == (nativehandle)ky2
        }
        #else{
             #assert(false, "The value-type \{#"U")} does not overload the == operator for " + 
                            "comparing two \{#"U"}s for equality. Hence it cannot be used " + 
                            "as kye in an associative array")
        }
    }
    static zint getHashCode(U ky){
        #if(U is integer){
            return (zint)ky
        }
        #elif(U is string){
            return [InternalCall]str_hash(ky)
        }
        #elif(U is &){
            if(ky == null)
                return 0
            #if(getHashCode() -> zint in U)
                return ky.getHashCode()
            #else
                return (zint)(nativehandle)ky
        }
        #elif(getHashCode() -> zint in U){
            return ky.getHashCode()
        }
        #else{
            #assert(false, "The value-type \{#"U"} does not provide an instance method " +
                           "getHashCode() -> zint and can therefore not be used as key in an " + 
                           "associative array")
        }
    }
    ensureCapacity(zint offs = 1){
        zint maxLoad = (zint)(capacity * LOAD_FACTOR)
        if(size + offs >= maxLoad){
            var cap = capacity << 1
            maxLoad <<= 1
            while(size + offs >= maxLoad){
                cap <<= 1
                maxLoad <<= 1
            }
            rehash([InternalCall]nextPrime(cap))
        }
    }
    rehash(zint nwCap){
        
        var nwBuckets = new Bucket[nwCap]
        nwBuckets... <- buckets
        buckets = nwBuckets
        
        var oldSlots = slots
        slots = new [nwCap]
        capacity = nwCap
        
        
        for(var buck : buckets[: size]){
            bool unused
            zint hashCode = getHashCode(buck.key)
            getOrInsert(buck.key, hashCode, buck, unused, hashCode % nwCap, 0)
        }
           
    }
    
    Bucket addBucket(U ky, T val){
        return (buckets[size] = new (ky, value))
    }
    Bucket getLastBucket(){
        // assert size > 0
        return buckets[size - 1]
    }
    
    ref Slot$ search(U ky, zint hashCode, bool &found, zint index){
        // search without insert
        uint dist = 0
        macro handleSlot(s, i) {
            if(!s.isFull()){
                found = false
                index = i
                return &s // not found
            }
            else if(s.hashCode == hashCode | 1 && equals(ky, s.buck.ky)){
                found = true
                index = i
                return &s // found
            }
            else if(s.distance < dist){
                found = false
                index = i
                return &s // not found (insertion would have swapped here)
            }
            dist++
        }
        for(zint i => var& s: slots[hashCode % capacity : ]){
            @handleSlot(s, i)
        }
        for(zint i => var& s: slots[ : hashCode % capacity]){
            @handleSlot(s, i)
        }
        [Builtin]unreachable()
    }
    ref Slot$ getOrInsert(U ky, zint hashCode, T value, bool replace, bool& inserted){
        ensureCapacity()
        uint dist = 0
        // new feature-request: lambda-macro
        macro handleSlot(i, s) {
            if(!s.isFull()){
                //buckets[currBucketIdx][currBucketFill] = new (ky, value)
                var buck = addBucket(ky, value)
                s = new (hashCode, buck, dist)
                inserted = true
                size++
                return &s
            }
            else if(s.hashCode == hashCode | 1 && equals(ky, s.buck.ky)){
                inserted = replace
                if(replace){
                    s.buck = new (ky, value)
                }
                return &s
            }
            else if(s.distance < dist){
                // not there => must be inserted
                //buckets[currBucketIdx][currBucketFill] = new (ky, value)
                var buck = addBucket(ky, value)
                
                var rhKy = s.buck.key
                var rhHashCode = s.hashCode
                var rhDistance = s.distance
                var rhBuck = s.buck
                
                s = new (hashCode, buck, dist)
                size++
                // tail call
                return &getOrInsert(rhKy, rhHashCode, rhBuck, inserted, i + 1, rhDistance + 1)
            }
            dist++
        }
        for(zint i => Slot$& s: slots[hashCode % capacity : ]){
            @handleSlot(i, s)
        }
        for(zint i => Slot$& s: slots[ : hashCode % capacity]){
            @handleSlot(i, s)
        }
        [Builtin]unreachable()
    }
    ref Slot$ getOrInsert(U ky, zint hashCode, Bucket! buck, bool& inserted, zint hc, uint dist){
        macro handleSlot(i, s) {
            if(!s.isFull()){
                s = new (hashCode, buck, dist)
                inserted = true
                return &s
            }
            else if(s.distance < dist){
                var rhKy = s.buck.key
                var rhHashCode = s.hashCode
                var rhDistance = s.distance
                var rhBuck = s.buck
                
                s = new (hashCode, buck, dist)
                
                // tail recursion
                return &getOrInsert(rhKy, rhHashCode, rhBuck, inserted, i + 1, rhDistance + 1)
            }
            dist++
        }
        for(zint i => Slot$& s: slots[hc : ]){
            @handleSlot(i, s)
        }
        for(zint i => Slot$& s: slots[ : hc]){
            @handleSlot(i, s)
        }
        [Builtin]unreachable()
    }
    
    public iterator (U, ref T) getIterator(){
        for(var buck : buckArr[: size]){
            yield (buck.key, &buck.value)
        }
    }
    
    public macro forEach({fn}){
        for(public U %key, public ref T %value : this){
            fn
        }
    }
    
    public bool insert(U ky, T value, bool replace){
        bool ret
        getOrInsert(ky, getHashCode(ky), value, replace, ret)
        return ret
    }
    
    public ref T operator[](U ky){
        #if(default in T){ // null is the default for every nullable reference-type
            bool unused
            return &getOrInsert(ky, getHashCode(ky), default(T), false, unused).buck.value
        }
        #elif(ctor() in T && T is $){
            bool unused
            return &getOrInsert(ky, getHashCode(ky), new T(), false, unused).buck.value
        }
        #else{
            bool found
            zint index
            ref Slot$ s = search(ky, getHashCode(ky), found, index)
            if(found){
                return &s.buck.value
            }
            else{
                throw new KeyNorFoundException("Key \{ky} not found")
            }
        }
    }
    public ref T operator[](U ky, T val) #if (!default in T && !(ctor() in T && T is $)){
        bool unused
        return &getOrInsert(ky, getHashCode(ky), val, false, unused).buck.value
    }
    
    public bool tryGetValue(U ky, T &out_val){
        bool found
        zint index
        var s = &search(ky, getHashCode(ky), found, index)
        if(found)
            out_val = s.buck.value
        return found
    }
    
    bool remove(U ky){
        
        zint hashCode = getHashCode(ky)
        bool found
        zint index
        ref Slot$ s = search(ky, hashCode, found, index)
        if(!found)
            return false
            
        // swap Bucket$s not possible, since we have to preserve the references
        // Hence use Bucket!s
        if(--size){
            var buck = getLastBucket()
            zint unused
            var last = &search(buck.key, getHashCode(buck.key), found, unused)
            s.buck = last
            last = null
        }
        
        s.clear()
        
        macro backShift(i, last_i) {
            if(!slots[i].isFull() || slots[i].distance == 0)
                return true
            slots[last_i] = slots[i]
            slots[last_i].distance --
            slots[i].clear()
        }
        
        for(zint i : index + 1 to capacity){
            @backShift(i, i - 1)
        }
        @backShift(0, capacity - 1)
        for(zint i : 1 to index){
            @backShift(i, i - 1)
        }
        [Builtin]unreachable()
    }
    
    
    public ctor((U => T)... args){
        //ensureCapacity((zint)(args.length * (1/LOAD_FACTOR)))
        ctor((zint)(args.length * (1/LOAD_FACTOR)))
        for(U ky => T val : args){
            insert(ky, val, false)
        }
    }
    
    public ctor(zint initCap){
        capacity = [InternalCall]nextPrime(initCap)
        slots = new [capacity]
        buckets = new [capacity]
    }
    public ctor(){
        ctor(5)
    }
    
    
    Slot$[] slots
    Bucket[] buckets
    zint capacity, size
}